from ortools.sat.python import cp_model

def solve_timetabling(N, M, d, c, conflict_pairs):
    model = cp_model.CpModel()
    max_slots = N
    slot = [model.NewIntVar(1, max_slots, f"slot_{i}") for i in range(N)]
    room = [model.NewIntVar(1, M, f"room_{i}") for i in range(N)]
    for i, j in conflict_pairs:
        model.Add(slot[i] != slot[j])
    for i in range(N):
        for r in range(1, M+1):
            if c[r-1] < d[i]:
                model.Add(room[i] != r)
    for i in range(N):
        for j in range(i+1, N):
            b = model.NewBoolVar(f"same_slot_{i}_{j}")
            model.Add(slot[i] == slot[j]).OnlyEnforceIf(b)
            model.Add(slot[i] != slot[j]).OnlyEnforceIf(b.Not())
            model.Add(room[i] != room[j]).OnlyEnforceIf(b)
    #objective
    max_slot_used = model.NewIntVar(1, max_slots, "max_slot_used")
    model.AddMaxEquality(max_slot_used, slot)
    model.Minimize(max_slot_used)

    # Solve
    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = 30
    solver.parameters.num_search_workers = 8
    result = solver.Solve(model)

    if result in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        slots = [solver.Value(slot[i]) for i in range(N)]
        rooms = [solver.Value(room[i]) for i in range(N)]
        return slots, rooms
    else:
        return None, None

if __name__ == '__main__':
    import sys
    data = sys.stdin.read().split()
    it = iter(data)
    N = int(next(it)); M = int(next(it))
    d = [int(next(it)) for _ in range(N)]
    c = [int(next(it)) for _ in range(M)]
    K = int(next(it))
    pairs = [(int(next(it))-1, int(next(it))-1) for _ in range(K)]
    slots, rooms = solve_timetabling(N, M, d, c, pairs)
    if slots:
        for i in range(N):
            print(i+1, slots[i], rooms[i])
    else:
        print("No solution found")
